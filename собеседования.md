<details>
  <summary>[190] Магнит</summary>

# [1] Задача 
 ```sql
select count(distinct user_id), count(item_id) as cnt, date
from orders
group by date
order by date
 ```
# [2] Задача 
 ```sql
select distinct user_id from orders
where user_id in (select user_id from orders where item_id = 1)
and
user_id not in (select user_id from orders where item_id = 2)
and
user_id in (select user_id from orders where item_id = 3)
 ```

 # [3] Задача 
 ```sql
with tmp as(select user_id, order_id, date,
lead(date) over (partition by user_id order by date) as lg,
row_number() over (partition by user_id order by date) as rn
from orders),
tmp_2 as (select user_id, DATEDIFF('d', date, lg) as diff
from tmp 
where rn = 1 )
select avg(diff) from tmp_2
 ```
  # [4] Задача 
 ```python
s_new = ''
for i in range (len(s)-1):
  if s[i].isalnum():
    s_new += s[i].lower()

if s_new == s_new[::-1]:
  print(True)
else:
  print(False)
 ```
  # [5] Задача 
 ```python
import random
banners = ['a','b','c']
weights = [1,2,3]

def random_banner(banners, weights):
  return random.choices(banners, weights = weights)
 ```

</details>

<details>
  <summary>[189] Купер (mega hard sobes) (треш)</summary>

# [1] Задача 
inner
1 one another one
2 two two
2 two null
 - 3 строки

left

1 one another one
null null null
2 two two
2 two null
3 three null
null another null null
 - 6 строк

right

1 one another one
null null null
null null null
2 two two
2 two null
4 null four
5 null four
 - 7 строк

full
1 one another one 
null null 
null null 
null null 
2 two two 
2 two null 
3 three null 
4 null four 
5 null five 
null another null null
 - 10 строк

  # [2] Задача 
 ```sql
-- Необходимо вывести список клиентов, которые совершили покупки во всех категориях товаров, а также для каждого такого клиента рассчитать долю его трат в каждой категории от его общей суммы трат.

select distinct customer_id, category_id,
ROUND(
    (SUM(spent) OVER (PARTITION BY customer_id, category_id)::float 
     / 
     SUM(spent) OVER (PARTITION BY customer_id)::float * 100)::numeric,
    2
) as result
from sandbox.zvereva_kuper
where customer_id IN(
  select distinct customer_id from sandbox.zvereva_kuper where category_id = 1
)
and
customer_id IN(
  select distinct customer_id from sandbox.zvereva_kuper where category_id = 2
)
and
customer_id IN(
  select distinct customer_id from sandbox.zvereva_kuper where category_id = 3
)
order by customer_id,category_id

 ```
# [3] Задача 

1) Разные типы данных в price
2) Отсутствует primary key
3) Отсутствие атомарности данных - лучше разбить фио на 3 столбца или заменить на ункиальный id
4) Отсутствие проверки на разное написание одного и того же слова (Шестерочка)
5) Менеджер зависит от магазина, то есть в текущей ситуации при смене менеджера нужно обновлять данные покупки (лучше бы менеджер-магазин были в другой таблице)
6) Есть дубликаты

# [4] Задача 

list:
- list[i] O(1)
- list.append() O(1)
- list.pop() O(1)
- x in list O(n)

dist:
- dist[key] O(1)
- dist[key] = value O(1)
- del dist[key] O(1)
- key in dist O(1)

set:
- x in set O(1)
- set.add() O(1)
- set.remove() O(1)
- len(set) O(1)

# [5] Задача 
[[0,1,1][0,1,1][0,1,1]]

# [6] Задача 
lambda - безымянная функция, которую мы задаем и вызываем в моменте

когда стоит использовать:
- когда нам нужно выполнить небольшую операцию на месте
- когда нужно передать функцию как аргумент

когда не стоит использовать:
- когда сложность операции высокая и функция мешает читабельности кода
- когда нужно многоразовое использование функции

 ```python
result = []
a = ['2', '1', '3', '4']

result = list(map(lambda i: int(a[0])**int(a[i+1]), range(len(a)-1)))

 ```
# [7] Задача 
Что такое итератор?
- Правильное определение: объект, который умеет последовательно выдавать элементы коллекции один за другим при помощи метода __next__()
- нужны для перебора элементов, чаще всего в циклах for

Что такое генератор?
- специальный тип итератора, который создаёт элементы «на лету» с помощью функции с yield
- используется для экономии памяти и создания последовательностей, которые не нужно хранить полностью в памяти

Что такое контекстный менеджер?
- объект, который управляет ресурсами и гарантирует их корректное открытие/закрытие
- позволяет не писать вручную try/finally для освобождения ресурсов

Что такое декоратор?
- функция, которая принимает другую функцию и возвращает новую функцию с добавленным поведением
- используется для расширения функциональности без изменения исходного кода функции

 ```python
def decorator(func):
    def wrapper():
        result = func()
        return result
    return wrapper

@decorator
def get_name ():
  return 'Купер-купер'
```
# [8] Задача 

[1, 2, 3] [1, 2, 3] 

# [8] Задача 

Чтобы повышать надежность процесса, я буду:
- Создавать резервные копии исходных данных (например, сохранять их в отдельной папке или на облаке), чтобы можно было восстановить процесс при сбое
- Использовать логирование и контроль ошибок, чтобы отслеживать, где и почему процесс может упасть
- Разбивать процесс на пошаговые этапы с проверками качества данных, чтобы быстро выявлять некорректные или пропущенные значения
- Хранить промежуточные результаты (например, в CSV или базе), чтобы можно было не начинать обработку заново с нуля, если что-то пойдет не так

# [9] Задача

Существует несколько видов тестирования приложений: функциональное тестирование, нагрузочное, пользовательское и A/B-тестирование. Как аналитик я сталкивалась с пользовательским тестированием (кастдев) и A/B-тестами, где мы сравнивали, как изменения в продукте влияют на ключевые метрики, например конверсии или удержание пользователей. Это помогает принимать решения на основе данных и минимизировать риски внедрения новых функций

# [10] Задача

 ```python
import random
banners = ['a','b','c']
weights = [1,2,3]

def random_banner(banners, weights):
  return random.choices(banners, weights = weights)
 ```

# [12] Задача

 ```python
'''Базовый анализ A/B'''

df = events_df. merge(users_df, on = 'user_id', how = 'inner')

df.groupby('group').agg({
    'amount': 'mean',
    'event_type': 'count'
})

df[df['event_type'] == 'purchase'].groupby('group').agg({'amount':'mean'})

'''Посчитаем ARPU'''
revenue = df[df['event_type'] == 'purchase'].groupby('group').agg({
    'amount':sum
})

countt = df.groupby('group').agg({
    'user_id':'nunique'
})

arpu = (revenue['amount']/countt['user_id']).round(2).rename('arpu')

'''Посчитаем стат значимость'''

revenue_per_user = df.groupby(['user_id', 'group'])['amount'].sum().reset_index()

control_revenue = revenue_per_user[revenue_per_user['group'] == 'control']['amount']
test_revenue = revenue_per_user[revenue_per_user['group'] == 'test']['amount']


t_stat, p_value = stats.ttest_ind(control_revenue, test_revenue, equal_var=False)
p_value

'''p_value = 0.9407 / Это больше 0,05, поэтому нулевую гипотезу мы отклонить не можем - разница статистически незначима'''
 ```

</details>


<details>
  <summary>[188] ВТБ Data Steward (aka Data инженерная вака) </summary> вс

# [1] Задача 

1) OLAP / OLTP -> какая разница
OLTP - это вид БД, когда можно делать много коротких операций, поскольку процесс позволяет быстро изменять данные, но долго делать запросы
OLAP - это вид БД, когда изменять данные приходится долго, но зато запросы выполняются гораздо быстрее

2) MPP
архитектура, где много процессоров работают над разными частями задачи одновременно

3) ACID
- это процесс, который позволяет данными не быть ошибочными, нарушенными

4) Логические и физические джоины
Логические - что мы хотим получить (иннер, лефт, райт, фулл, кросс джойны)
Физические - как СУБД выполняет (хаш, мердж)


5) m и n строк при inner / left джоине - максимальное и мин. кол-во строк (!) FULL JOIN минимальное кол-во
inner
min - 0
max - m*n

left
min - m
max - m*n

full
min - max(m,n)
max - m*n

6) что такое constraint'ы
это правила для целостности данных:
primary key, foreign key
unique
not null
check

7) что такое индексы
- объекты, которые позволяют ускорять процессы путем запоминания части данных (но могут требовать больше памяти, если ими пользоваться неоптимально)

8) что будешь делать, если расчет ETL идет слишком долго - чтобы ты пошел проверять (вопрос про партицирование)
- обрабатываем только нужные партиции
- возможно нужно отключить индексы
- размер батчей

9) Репликация
это создание и поддержание копий данных на нескольких серверах

10) SQL

 ```sql
select date, 
sum(cash_flow) over (order by date) as cumulative_cf
from transactions
```
11) SQL

 ```sql
with tmp as(
  select employee_id, name, skill, salary,
  sum(salary) over (order by skill desc, salary DESC) as sal_res
  from sandbox.zvereva_testt
  order by sal_res, skill
)
select employee_id, name, skill, salary, sal_res
from tmp
where sal_res <= 500
ORDER BY skill DESC, salary desc
```

</details>


<details>
  <summary>[187] Райфайзен банк (Raif) </summary> пн

# [1] Задача 

 ```sql
select full_name from sandbox.zvereva_full_names
where full_name like '%ss%'
```
# [2] Задача 

 ```sql
with tmp as (select user_id, country_id,
sum(order_sum) as user_sum
from orders
where order_success = 1
group by  user_id, country_id),

tmp_2 as (
select country_id, 
sum(order_sum) as country_sum
from tmp
group by country_id)

select user_id, country_id,
user_sum/country_sum*100 as result
from tmp inner join tmp_2 using (country_id)

```

# [3] Задача (Python)

1) Изменяемые и неизменяемые
Изменяемые: list, set, dict
Неизменяемые: str, tuple, bites, float, int, bool

2) Словарь - что это такое?
Это изменяемый объект в пайтон, который позволяет хранить пары данных по ключу (ключ:значение), ключи должны быть неизменяемые

3) Как в текстовом файле подсчитать кол-во вхождений уникальных слов?
Сначала разделить текст на слова через split(), а потом перевести в set и посчитать count

4) Как определить, что все символы в строке уникальны?

Сравнить размер set и размер list (при этом возможно удалить пробелы)

# [4] Задача (Python)

 ```python
def two_max(arr):
  arr = sorted(arr, reverse = True)
  return arr[:2]
```
# [5] Задача (Python)

1 - Как вывести кол-во строк в датафрейме?
len(df)
df.shape[0]

2 - Как считать csv файл
df = pd.read_csv('', sep = '')

3 - Как ставить кодировку при чтении
encoding = 'utf-8'

4 - Вопрос про merge и concat
merge - аналог джойн в скл, когда мы соединяем данные по столбцу и по определенному способу
concat - просто склеиваем данные

5 - Вопрос на groupby + agg
groupby - группируем данные по какому-то столбцу (или по нескольким)
agg - выполняем агрегацию по столбцу или нескольким столбцам типа agg({'column': 'mean'})

6 - Вопрос про reset_index и as_index=False в groupby
as_index = False и reset_index делают одно и то же, но в разное время
При as_index = False мы в groupby задаем as_index = False и тогда группирующие столбцы не будут индексами
reset_index - сначала группируем, потом говорим, чтобы столбцы были столбцами, а не индексами

7 - Вопрос про value_counts и параметры этой функции для ratio расчета (normalize=True)
value_counts(normalize=True) - считает доли вместо абсолютных значений
value_counts(normalize=True)*100 - считает процент

</details>


<details>
  <summary>[186] Yandex One Day Offer (нужно решить A/B)</summary> вт

# [1] Задача (Python)

 ```python
'''Написать функцию, которая для заданного массива мест вычисляет это максимальное расстояние до ближайшего зрителя'''

def search_seat(seats):
  i = 0
  arr = []
  right = 0

  if sum(seats) > 1:

      while sum(seats[right+1::]) != 0:

        while i<=len(seats)-1 and seats[i] != 1:
          i += 1
        left = i
        i +=1

        while i<=len(seats)-1 and seats[i] != 1:
          i += 1
        right = i

        arr.append((right-left)//2)

      arr.append((len(seats)-1-right)//2)
      return max(arr)


  else: 
      for k in range (len(seats)):
        if seats[k] == 1:
          aim = k
          break
      
      return int((max(aim-0, len(seats)-1-aim)))

 ```

 # [2] Задача (Теорвер)

Сначала поняла, что тут условная вероятность и что-то типа парадокса Монти-Холла, но сама решить не смогла

1) Вероятность выбрать любой из ящиков - 1/3

2) Событие "первая монета золотая" может произойти в случаях:
1 ящик: 0 * 1/3 = 0
2 ящик: 1/2 * 1/3 = 1/6
3 ящик: 1 * 1/3 = 1/3
По полной вероятности вероятность вытянуть первой монету = 1/6+1/3 = 1/2

3) Вторую золотую мы достанем только если выбран 3 ящик: 1/3*1 = 1/3

4) 1/3 / 1/2 = 2/3

 # [3] Задача (A/B)


</details>

<details>
  <summary>[185] Ecom Tech (Самокат) (нужно дорешать про АБ)</summary> ср

 # [0] Задача (На логику)

192

 # [1] Задача 
 0 строк, потому что null не равно никакому другому значению

 # [2] Задача 
UNKNOWN OR UNKNOWN OR UNKNOWN OR TRUE = TRUE, поэтому вернутся все строки

 # [3] Задача 

 ```sql
 with tmp as (select DATETRUNC(MONTH, created_time) as month, 
  customer_id,
  sum(amount) as sm
  from transactions
  group by DATETRUNC(MONTH, created_time), customer_id),

 tmp_2 as (select month, 
  customer_id, 
  sm, 
  rank() over (partition by month order by sm DESC) as rn
  from tmp)
select month, customer_id
from tmp_2
where rn <= 5
order by month, rn

  ```

# [4] Задача 

 ```python
from collections import Counter

def count_logs(logs):
  error_counts = [
  log.split(': ')[1]
  for log in logs]

  return dict(Counter(error_counts))

```

# [5] Задача 

 ```python
def counter(s):
  count = 1
  maxi = 0
  s = s+' '
  for i in range (len(s)-1):
    if s[i] == s[i+1]:
      count +=1
    else:
      maxi = max(maxi, count)
      count = 1
  return maxi

```
# [6] Задача 
Еще спросили про полный цикл АБ, как будешь делать АБ на то, что кнопка заказа была черная, а стала красной

</details>


<details>
  <summary>[184] Ozon Банк</summary> чт

# [1] Задача 

 ```sql
with tmp as (select distinct score
from sandbox.zvereva_athlete
order by score desc),

tmp_2 as (select score,
count(*) over (order by score DESC ROWS UNBOUNDED PRECEDING) as rank
from tmp)

select tmp_2.score, a.athlete_id, tmp_2.rank
from sandbox.zvereva_athlete a left join tmp_2 using (score)

```


</details>