<details>
  <summary>[190] Магнит</summary>

# [1] Задача 
 ```sql
select count(distinct user_id), count(item_id) as cnt, date
from orders
group by date
order by date
 ```
# [2] Задача 
 ```sql
select distinct user_id from orders
where user_id in (select user_id from orders where item_id = 1)
and
user_id not in (select user_id from orders where item_id = 2)
and
user_id in (select user_id from orders where item_id = 3)
 ```

 # [3] Задача 
 ```sql
with tmp as(select user_id, order_id, date,
lead(date) over (partition by user_id order by date) as lg,
row_number() over (partition by user_id order by date) as rn
from orders),
tmp_2 as (select user_id, DATEDIFF('d', date, lg) as diff
from tmp 
where rn = 1 )
select avg(diff) from tmp_2
 ```
  # [4] Задача 
 ```python
s_new = ''
for i in range (len(s)-1):
  if s[i].isalnum():
    s_new += s[i].lower()

if s_new == s_new[::-1]:
  print(True)
else:
  print(False)
 ```
  # [5] Задача 
 ```python
import random
banners = ['a','b','c']
weights = [1,2,3]

def random_banner(banners, weights):
  return random.choices(banners, weights = weights)
 ```

</details>

<details>
  <summary>[189] Купер (mega hard sobes) (треш)</summary>

# [1] Задача 
inner
1 one another one
2 two two
2 two null
 - 3 строки

left

1 one another one
null null null
2 two two
2 two null
3 three null
null another null null
 - 6 строк

right

1 one another one
null null null
null null null
2 two two
2 two null
4 null four
5 null four
 - 7 строк

full
1 one another one 
null null 
null null 
null null 
2 two two 
2 two null 
3 three null 
4 null four 
5 null five 
null another null null
 - 10 строк

  # [2] Задача 
 ```sql
-- Необходимо вывести список клиентов, которые совершили покупки во всех категориях товаров, а также для каждого такого клиента рассчитать долю его трат в каждой категории от его общей суммы трат.

select distinct customer_id, category_id,
ROUND(
    (SUM(spent) OVER (PARTITION BY customer_id, category_id)::float 
     / 
     SUM(spent) OVER (PARTITION BY customer_id)::float * 100)::numeric,
    2
) as result
from sandbox.zvereva_kuper
where customer_id IN(
  select distinct customer_id from sandbox.zvereva_kuper where category_id = 1
)
and
customer_id IN(
  select distinct customer_id from sandbox.zvereva_kuper where category_id = 2
)
and
customer_id IN(
  select distinct customer_id from sandbox.zvereva_kuper where category_id = 3
)
order by customer_id,category_id

 ```
# [3] Задача 

1) Разные типы данных в price
2) Отсутствует primary key
3) Отсутствие атомарности данных - лучше разбить фио на 3 столбца или заменить на ункиальный id
4) Отсутствие проверки на разное написание одного и того же слова (Шестерочка)
5) Менеджер зависит от магазина, то есть в текущей ситуации при смене менеджера нужно обновлять данные покупки (лучше бы менеджер-магазин были в другой таблице)
6) Есть дубликаты

# [4] Задача 

list:
- list[i] O(1)
- list.append() O(1)
- list.pop() O(1)
- x in list O(n)

dist:
- dist[key] O(1)
- dist[key] = value O(1)
- del dist[key] O(1)
- key in dist O(1)

set:
- x in set O(1)
- set.add() O(1)
- set.remove() O(1)
- len(set) O(1)

# [5] Задача 
[[0,1,1][0,1,1][0,1,1]]

# [6] Задача 
lambda - безымянная функция, которую мы задаем и вызываем в моменте

когда стоит использовать:
- когда нам нужно выполнить небольшую операцию на месте
- когда нужно передать функцию как аргумент

когда не стоит использовать:
- когда сложность операции высокая и функция мешает читабельности кода
- когда нужно многоразовое использование функции

 ```python
result = []
a = ['2', '1', '3', '4']

result = list(map(lambda i: int(a[0])**int(a[i+1]), range(len(a)-1)))

 ```
# [7] Задача 
Что такое итератор?
- Правильное определение: объект, который умеет последовательно выдавать элементы коллекции один за другим при помощи метода __next__()
- нужны для перебора элементов, чаще всего в циклах for

Что такое генератор?
- специальный тип итератора, который создаёт элементы «на лету» с помощью функции с yield
- используется для экономии памяти и создания последовательностей, которые не нужно хранить полностью в памяти

Что такое контекстный менеджер?
- объект, который управляет ресурсами и гарантирует их корректное открытие/закрытие
- позволяет не писать вручную try/finally для освобождения ресурсов

Что такое декоратор?
- функция, которая принимает другую функцию и возвращает новую функцию с добавленным поведением
- используется для расширения функциональности без изменения исходного кода функции

 ```python
def decorator(func):
    def wrapper():
        result = func()
        return result
    return wrapper

@decorator
def get_name ():
  return 'Купер-купер'
```
# [8] Задача 

[1, 2, 3] [1, 2, 3] 

# [8] Задача 

Чтобы повышать надежность процесса, я буду:
- Создавать резервные копии исходных данных (например, сохранять их в отдельной папке или на облаке), чтобы можно было восстановить процесс при сбое
- Использовать логирование и контроль ошибок, чтобы отслеживать, где и почему процесс может упасть
- Разбивать процесс на пошаговые этапы с проверками качества данных, чтобы быстро выявлять некорректные или пропущенные значения
- Хранить промежуточные результаты (например, в CSV или базе), чтобы можно было не начинать обработку заново с нуля, если что-то пойдет не так

# [9] Задача

Существует несколько видов тестирования приложений: функциональное тестирование, нагрузочное, пользовательское и A/B-тестирование. Как аналитик я сталкивалась с пользовательским тестированием (кастдев) и A/B-тестами, где мы сравнивали, как изменения в продукте влияют на ключевые метрики, например конверсии или удержание пользователей. Это помогает принимать решения на основе данных и минимизировать риски внедрения новых функций

# [10] Задача

 ```python
import random
banners = ['a','b','c']
weights = [1,2,3]

def random_banner(banners, weights):
  return random.choices(banners, weights = weights)
 ```

# [12] Задача

 ```python
'''Базовый анализ A/B'''

df = events_df. merge(users_df, on = 'user_id', how = 'inner')

df.groupby('group').agg({
    'amount': 'mean',
    'event_type': 'count'
})

df[df['event_type'] == 'purchase'].groupby('group').agg({'amount':'mean'})

'''Посчитаем ARPU'''
revenue = df[df['event_type'] == 'purchase'].groupby('group').agg({
    'amount':sum
})

countt = df.groupby('group').agg({
    'user_id':'nunique'
})

arpu = (revenue['amount']/countt['user_id']).round(2).rename('arpu')

'''Посчитаем стат значимость'''

revenue_per_user = df.groupby(['user_id', 'group'])['amount'].sum().reset_index()

control_revenue = revenue_per_user[revenue_per_user['group'] == 'control']['amount']
test_revenue = revenue_per_user[revenue_per_user['group'] == 'test']['amount']


t_stat, p_value = stats.ttest_ind(control_revenue, test_revenue, equal_var=False)
p_value

'''p_value = 0.9407 / Это больше 0,05, поэтому нулевую гипотезу мы отклонить не можем - разница статистически незначима'''
 ```

</details>


<details>
  <summary>[188] ВТБ Data Steward (aka Data инженерная вака) </summary> вс

# [1] Задача 

1) OLAP / OLTP -> какая разница
OLTP - это вид БД, когда можно делать много коротких операций, поскольку процесс позволяет быстро изменять данные, но долго делать запросы
OLAP - это вид БД, когда изменять данные приходится долго, но зато запросы выполняются гораздо быстрее

2) MPP
архитектура, где много процессоров работают над разными частями задачи одновременно

3) ACID
- это процесс, который позволяет данными не быть ошибочными, нарушенными

4) Логические и физические джоины
Логические - что мы хотим получить (иннер, лефт, райт, фулл, кросс джойны)
Физические - как СУБД выполняет (хаш, мердж)


5) m и n строк при inner / left джоине - максимальное и мин. кол-во строк (!) FULL JOIN минимальное кол-во
inner
min - 0
max - m*n

left
min - m
max - m*n

full
min - max(m,n)
max - m*n

6) что такое constraint'ы
это правила для целостности данных:
primary key, foreign key
unique
not null
check

7) что такое индексы
- объекты, которые позволяют ускорять процессы путем запоминания части данных (но могут требовать больше памяти, если ими пользоваться неоптимально)

8) что будешь делать, если расчет ETL идет слишком долго - чтобы ты пошел проверять (вопрос про партицирование)
- обрабатываем только нужные партиции
- возможно нужно отключить индексы
- размер батчей

9) Репликация
это создание и поддержание копий данных на нескольких серверах

10) SQL

 ```sql
select date, 
sum(cash_flow) over (order by date) as cumulative_cf
from transactions
```
11) SQL

 ```sql
with tmp as(
  select employee_id, name, skill, salary,
  sum(salary) over (order by skill desc, salary DESC) as sal_res
  from sandbox.zvereva_testt
  order by sal_res, skill
)
select employee_id, name, skill, salary, sal_res
from tmp
where sal_res <= 500
ORDER BY skill DESC, salary desc
```

</details>


<details>
  <summary>[187] Райфайзен банк (Raif) </summary> пн

# [1] Задача 

 ```sql
select full_name from sandbox.zvereva_full_names
where full_name like '%ss%'
```
# [2] Задача 

 ```sql
with tmp as (select user_id, country_id,
sum(order_sum) as user_sum
from orders
where order_success = 1
group by  user_id, country_id),

tmp_2 as (
select country_id, 
sum(order_sum) as country_sum
from tmp
group by country_id)

select user_id, country_id,
user_sum/country_sum*100 as result
from tmp inner join tmp_2 using (country_id)

```

# [3] Задача (Python)

1) Изменяемые и неизменяемые
Изменяемые: list, set, dict
Неизменяемые: str, tuple, bites, float, int, bool

2) Словарь - что это такое?
Это изменяемый объект в пайтон, который позволяет хранить пары данных по ключу (ключ:значение), ключи должны быть неизменяемые

3) Как в текстовом файле подсчитать кол-во вхождений уникальных слов?
Сначала разделить текст на слова через split(), а потом перевести в set и посчитать count

4) Как определить, что все символы в строке уникальны?

Сравнить размер set и размер list (при этом возможно удалить пробелы)

# [4] Задача (Python)

 ```python
def two_max(arr):
  arr = sorted(arr, reverse = True)
  return arr[:2]
```
# [5] Задача (Python)

1 - Как вывести кол-во строк в датафрейме?
len(df)
df.shape[0]

2 - Как считать csv файл
df = pd.read_csv('', sep = '')

3 - Как ставить кодировку при чтении
encoding = 'utf-8'

4 - Вопрос про merge и concat
merge - аналог джойн в скл, когда мы соединяем данные по столбцу и по определенному способу
concat - просто склеиваем данные

5 - Вопрос на groupby + agg
groupby - группируем данные по какому-то столбцу (или по нескольким)
agg - выполняем агрегацию по столбцу или нескольким столбцам типа agg({'column': 'mean'})

6 - Вопрос про reset_index и as_index=False в groupby
as_index = False и reset_index делают одно и то же, но в разное время
При as_index = False мы в groupby задаем as_index = False и тогда группирующие столбцы не будут индексами
reset_index - сначала группируем, потом говорим, чтобы столбцы были столбцами, а не индексами

7 - Вопрос про value_counts и параметры этой функции для ratio расчета (normalize=True)
value_counts(normalize=True) - считает доли вместо абсолютных значений
value_counts(normalize=True)*100 - считает процент

</details>


<details>
  <summary>[186] Yandex One Day Offer (нужно решить A/B)</summary> вт

# [1] Задача (Python)

 ```python
'''Написать функцию, которая для заданного массива мест вычисляет это максимальное расстояние до ближайшего зрителя'''

def search_seat(seats):
  i = 0
  arr = []
  right = 0

  if sum(seats) > 1:

      while sum(seats[right+1::]) != 0:

        while i<=len(seats)-1 and seats[i] != 1:
          i += 1
        left = i
        i +=1

        while i<=len(seats)-1 and seats[i] != 1:
          i += 1
        right = i

        arr.append((right-left)//2)

      arr.append((len(seats)-1-right)//2)
      return max(arr)


  else: 
      for k in range (len(seats)):
        if seats[k] == 1:
          aim = k
          break
      
      return int((max(aim-0, len(seats)-1-aim)))

 ```

 # [2] Задача (Теорвер)

Сначала поняла, что тут условная вероятность и что-то типа парадокса Монти-Холла, но сама решить не смогла

1) Вероятность выбрать любой из ящиков - 1/3

2) Событие "первая монета золотая" может произойти в случаях:
1 ящик: 0 * 1/3 = 0
2 ящик: 1/2 * 1/3 = 1/6
3 ящик: 1 * 1/3 = 1/3
По полной вероятности вероятность вытянуть первой монету = 1/6+1/3 = 1/2

3) Вторую золотую мы достанем только если выбран 3 ящик: 1/3*1 = 1/3

4) 1/3 / 1/2 = 2/3

 # [3] Задача (A/B)


</details>

<details>
  <summary>[185] Ecom Tech (Самокат) (нужно дорешать про АБ)</summary> ср

 # [0] Задача (На логику)

192

 # [1] Задача 
 0 строк, потому что null не равно никакому другому значению

 # [2] Задача 
UNKNOWN OR UNKNOWN OR UNKNOWN OR TRUE = TRUE, поэтому вернутся все строки

 # [3] Задача 

 ```sql
 with tmp as (select DATETRUNC(MONTH, created_time) as month, 
  customer_id,
  sum(amount) as sm
  from transactions
  group by DATETRUNC(MONTH, created_time), customer_id),

 tmp_2 as (select month, 
  customer_id, 
  sm, 
  rank() over (partition by month order by sm DESC) as rn
  from tmp)
select month, customer_id
from tmp_2
where rn <= 5
order by month, rn

  ```

# [4] Задача 

 ```python
from collections import Counter

def count_logs(logs):
  error_counts = [
  log.split(': ')[1]
  for log in logs]

  return dict(Counter(error_counts))

```

# [5] Задача 

 ```python
def counter(s):
  count = 1
  maxi = 0
  s = s+' '
  for i in range (len(s)-1):
    if s[i] == s[i+1]:
      count +=1
    else:
      maxi = max(maxi, count)
      count = 1
  return maxi

```
# [6] Задача 
Еще спросили про полный цикл АБ, как будешь делать АБ на то, что кнопка заказа была черная, а стала красной

</details>


<details>
  <summary>[184] Ozon Банк</summary> чт

# [1] Задача 

 ```sql
with tmp as (select distinct score
from sandbox.zvereva_athlete
order by score desc),

tmp_2 as (select score,
count(*) over (order by score DESC ROWS UNBOUNDED PRECEDING) as rank
from tmp)

select tmp_2.score, a.athlete_id, tmp_2.rank
from sandbox.zvereva_athlete a left join tmp_2 using (score)

```


</details>


<details>
  <summary>[183] Solva</summary> пт

# [1] Задача 

Кол-во закрытых кредитов:
 ```sql
select product_group, count(distinct credit_id) as cnt,
avg(sent_amount) as ag
from credit
where status = 'COMPLETED' and date_trunc('year', date_requested) = 2022
group by product_group

```
1. Как будет выглядеть запрос, если в таблице есть полные дубликаты?

 ```sql
with tmp as(
  select credit_id, sent_amount, status, date_requested, date_completed, issued_ind, product_group, client_id,
  row_number() over (partition by credit_id, sent_amount, status, date_requested, date_completed, issued_ind, product_group, client_id) as cnt_dup
  from credit
)
select product_group, count(distinct credit_id) as cnt,
avg(sent_amount) as ag
from tmp
where status = 'COMPLETED' and date_trunc('year', date_requested) = 2022 and cnt_dup =1
group by product_group
```
2. Как будет выглядеть запрос, если нужно оставить только те продукты, у которых получилось больше 5 закрытых кредитов.

 ```sql
select product_group, count(distinct credit_id) as cnt,
avg(sent_amount) as ag
from credit
where status = 'COMPLETED' and date_trunc('year', date_requested) = 2022
group by product_group
having count(distinct credit_id) > 5

```
# [2] Задача 
 ```sql
-- Используя таблицу credit, по каждому клиенту вывести сумму его первого закрытого кредита и сумму последнего закрытого кредита.

with tmp as (select client_id, sent_amount_first,  sent_amount_final,
row_number () over (partition by client_id order by date_completed) as first,
row_number () over (partition by client_id order by date_completed desc) as final
from credit
where status = 'COMPLETED'),

tmp_2 as (select client_id, sent_amount_first
from tmp
where first = 1),

tmp_3 as (select client_id, sent_amount_final
from tmp
where final = 1)

select tmp_2.client_id, sent_amount_first, sent_amount_final
from tmp_2 join tmp_3 using (client_id)

```
# [3] Задача 

 ```sql
--У тебя есть ещё одна таблица returns. Она содержит данные по выданным займам, на которые оформили возврат средств в этот же день. Напиши запрос, который выведет клиентов, получивших деньги и не делавших возврат.

with tmp as (select
client_id, date_returned
from credit c left join returns r on c.credit_id = r.credit_id
where issued_ind = 1)
select client_id from tmp
where date_returned is null
```
# [4] Задача 
 ```sql
--У тебя есть ещё одна таблица credit_calculations. Она отражает события и статусы по выданным займам на каждый день их жизни. Напиши запрос, который покажет в разрезе продуктов:  

-- количество выданных займов
select product_group, count(distinct credit_id) as cnt
from credit_calculations join credit using (credit_id)
group by credit_id

-- количество займов, вышедших в просрочку хотя-бы раз
select product_group, count(distinct credit_id) as cnt
from credit_calculations join credit using (credit_id)
where credit_id in (
  select distinct credit_id from credit_calculations where status = 'expired'
)
group by credit_id

-- количество займов, вышедших в непрерывную просрочку 7 дней

select product_group, count(distinct credit_id) as cnt
from credit_calculations join credit using (credit_id)
where credit_id in (
  select distinct credit_id from credit_calculations where status = 'expired' and status_days_count > 7
)
group by credit_id

-- максимальное количество выходов в просрочку 7 дней

```
# [4] Задача 
- Как будет соотноситься медиана и среднее по заработной плате в Казахстане?

Медиана будет сильно меньше среднего

- К тебе пришел продакт менеджер и просит рассчитать среднее время от отправки SMS до получения. Сложим время отправки всех SMS и поделив на количество, ты получил 500 сек. Как ты это интерпретируешь?

Нужно в числителе складывать не время отправки, а разницу между получением и отправкой. И тогда уже узнаем, за сколько секунд в среднем (арифметически) доставляется смс

# [5] Задача 

- Что такое мощность в контексте аб тестирования. Как связана с объёмом выборки?

Мощность - это 1-бетта(ошибка 2 рода), то есть вероятность обнаружить эффект, если он действительно есть. Чем больше объём выборки, тем больше мощность теста
- Как интерпретировать p-value в контексте A/B-тестирования?
p-value - это вероятность того, что значение будет принимать такое или более экстремальное значение, при условии, что нулевая гипотеза верна. Если p value < 0.05 (чаще всего), то мы можем считать разницу между метркиами статистически значимой

- Что такое множественное сравнение?
Например, когда у нас сразу несколько стат тестов, несколько АБ, то нужно делать поправку на множественное сравнение (например, Бонферрони)


- У нас две группы в тесте. В одной из них что-то поменяли. По тысяче заявок в каждой группе. Тебе нужно оценить изменения в среднем чеке. Будешь ли ты проверять распределение выдач на нормальность? Почему?

Распределение будет скошено, но из-за большого размера выборки даже небольшое отклонение от норм распр будет стат значимо, так что проверка на нормальность будет даже вредить. Поскольку используем т-тест (для сравнения средних) и выборка большая, так что можно воспользоваться ЦПТ и не проверять на нормальность

# [6] Задача 

У тебя есть следующие задачи:
  - Подготовка ежеквартального отчета по ключевым показателям.
  - Анализ существенного падения конверсии клиентов из регистрации в заявку.
  - Разработка модели для предсказания вероятности выхода займа в глубокую просрочку.
  - Дизайн A/B-теста новой формы заявки на микрозайм.
  
  Расставь приоритеты


1 - Анализ существенного падения конверсии клиентов из регистрации в заявку (метрика упала существенно, поэтому это важная и срочная задача)
2 - Дизайн A/B-теста новой формы заявки на микрозайм (есть потенциальная ценность для бизнеса, по скорости выполнения средняя)
3 - Подготовка ежеквартального отчета по ключевым показателям (это важная, но несрочная задача, но если квартал уже заканчивается, то затягивать не стоит)
4 - Разработка модели для предсказания вероятности выхода займа в глубокую просрочку (по времени задача небыстрая, вряд ли срочная, потому что это не так сильно влияет на ключевые показатели бизнеса, скорее как доп фича)

</details>


<details>
  <summary>[182] Ламода</summary> сб

# [1] Задача 

 ```sql
-- Напишите  запрос, который выведет статистику по количеству покупателей, привлеченных каждой маркетинговой акцией, которая есть у Вас в базе

select Name_MA, count(distinct o.Client_id) as Buyers
from sandbox.zvereva_ma left join sandbox.zvereva_clients using (Ma_ID) left join sandbox.zvereva_orders o using (Client_id)
group by Name_MA

```

# [2] Задача 

 ```sql
-- Напишите  запрос, который выведет помесячную статистику по задержанным заказам за 2006 год

with tmp as (select id, Moment as moment_a
from table
where status = 'a'),

tmp_1 as (select id, Moment as moment_s
from table
where status = 's')

select month(moment_a) as month, count(*) as Delayed_orders
from tmp join tmp_1 on tmp.id = tmp_1.id and datediff('dd', moment_a, moment_s)>3 
group by month


```
# [3] Задача 

 ```sql
-- Напишите запрос, который производит update таблицы Т и проставляет нужные значения.

with order_delays as(
select a.id,
a.Moment as moment_a, 
s.Moment as moment_s
from T a inner join T s on a.id = s.id and a.status = 'a' and s.status = 's' 
)
update T
SET IsDelayed = 
case when datediff(day, moment_a, moment_s)>3 then 1 else 0
end 
from T join order_delays using (id)
where status = 's'

```


</details>



<details>
  <summary>[181] Uzum</summary> вс

# [1] Задача 

 ```sql
-- 29.02.2024 по отношению к предыдущей неделе выросли просмотры мобильных пользователей. Необходимо проанализировать, изменилась ли структура просмотров по возрастным группам. Напишите запрос, который подготовит данные для проведения такого анализа. Пользователей разбейте на 4 группы:

select date, count(*) as cnt,
case when age < 18 then 'до 18 лет',
when age >= 18 and age < 60 then 'с 18 до 60 лет'
when age >= 60 then 'старше 60 лет'
when age is null then 'неизвестен'
end as age_group
from events
group by date, age_group
where event_type = 1 and (date = '2024-02-29' or date = '2024-02-29')


```

# [2] Задача 

 ```sql
-- В феврале 2024 года по отношению к январю 2024 произошло снижение CTR (Click-Through Rate, отношение количества кликов к количеству показов). Вам нужно проанализировать причины снижения

--1)

select 
case when extract(month from e.date) = 2 then 'Февраль'
  when extract(month from e.date) = 1 then 'Январь'
  end as period,
p.category,
round (count(case when event_type = 2 then 1 end)* 1.0 /
count(case when event_type = 1 then 1 end)*0.1,2)*100 as ctr
from sandbox.zvereva_events e inner join sandbox.zvereva_product p on e.product_id = p.id
where date >= '2024-01-01' and date < '2024-03-01' 
group by 
case when extract(month from e.date) = 2 then 'Февраль'
  when extract(month from e.date) = 1 then 'Январь'
end,
p.category

--2)
with tmp as (select 
case when extract(month from e.date) = 2 then 'Февраль'
  when extract(month from e.date) = 1 then 'Январь'
  end as period,
p.category,
round(count(case when event_type = 2 then 1 end)* 1.0 /
count(case when event_type = 1 then 1 end)*1.0 *100 , 2) as ctr
from sandbox.zvereva_events e inner join sandbox.zvereva_product p on e.product_id = p.id
where date >= '2024-01-01' and date < '2024-03-01' 
group by 
case when extract(month from e.date) = 2 then 'Февраль'
  when extract(month from e.date) = 1 then 'Январь'
end,
p.category
order by period)
select t.category, t.ctr as ctr_jan_2024, m.ctr as ctr_feb_2024
from tmp t join tmp m on t.category = m.category and t.period = 'Январь' and m.period = 'Февраль'
order by ctr_feb_2024 
limit 5

```
# [3] Задача 

 ```sql
-- Необходимо собрать статистику по всем событиям с мобильных устройств за 5 января 2024 в агрегации по 15 минутам с накоплением

with tmp as (select to_char(
DATE_TRUNC('hour', timestamp) + INTERVAL '15 min' * floor(extract (minute from timestamp)/15), 'YYYY-MM-DD HH24:MI') as min_15,
count(case when event_type = 1 then 1 end) as views,
count(case when event_type = 2 then 1 end) as clicks
from sandbox.zvereva_events
where date = '2024-01-05' and device_type = 'Mobile'
group by min_15)
select min_15, views, clicks,
sum(views) over (order by min_15) as views_cum,
sum(clicks) over (order by min_15) as clicks_cum
from tmp

```

# [4] Задача 

-- Даны цены по товарам и таблица диапазонов. Присвойте значения диапазонов следующим ценам, используя формулы

=ВПР(F6;$A$7:$B$14;2)

  </details>