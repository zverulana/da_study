<details>
  <summary>Сентябрь 2025</summary>

<details>
  <summary>Яндекс</summary>

пт
# [1] Задача 
 ```sql
with tmp as (select user_id, order_id,
row_number() over (partition by user_id order by order_timestamp) as rn
from taxi)
select user_id, order_id from tmp
where rn = 1

 ```
 # [2] Задача 
 ```sql
select t1.car_number
from sandbox.zvereva_taxi_orders t1 join sandbox.zvereva_taxi_orders t2 on t1.car_number = t2.car_number
and t1.endd>t2.start and t1.start<t2.endd

 ```
 # [3] Задача 
 ```python
'''1 вариант:'''

from collections import Counter

def find_mode (arr: list):
  arr = Counter(arr)
  return max (counter, key = counter.get)

'''2 вариант'''

def find_mode (arr: list):
  moda_count = 0
  k = 0
  arr = sorted(arr)
  for i in range (len(arr)-1):
    if arr[i] == arr[i+1]:
      k += 1
    else:
      if k > moda_count:
        moda_count = k
        moda = arr[i]
      k = 0
  return moda


 ```
 # [4] Задача 
 ```python

def func(d:dict):
  d_new = {}
  arr_keys = list(d.keys())
  arr_values = list(d.values())
  for i in range(len(d)):
    d_new.update ({ arr_values[i] : arr_keys[i]})

  return d_new

 ```

</details>

<details>
  <summary>ЭР-Телеком</summary>

сб
 # [1] Задача 
[1, 2, 3, 1, 2, 3]

 # [2] Задача 
arr = [x*2 for x in arr]

 # [3] Задача 

 1 
 2
 3 


 1

# [4] Задача 

Каждому человеку даем 2 стаканчика, он их пробует всплепую, очередность стаканчиков определяется рандомом. Затем собираем выборку из большого числа наблюдений. Считаем кол-во голосов за каждый вид колы, а затем с помощью стат теста проверяем, значимы ли статистически результаты. Стат тест берем биномиальный, потому что он подходит для бинарных выводов

(задача на двойное слепое тестирование)


</details>



<details>
  <summary>Т-банк</summary>

вс
# [1] Задача 

 ```sql
select t1.id, t1.department_id
from employee t1
join employee t2
on t1.department_id = t2.department_id 
and t1.chief_flg = False
and t2.chief_flg = True
and t1.birth_dt < t2.birth_dt
group by t1.id, t1.department_id
 ```

 # [2] Задача 

 ```sql
with tmp as (
  select transaction_id, customer_id, amount_rur, transaction_dttm,
  row_number() over (partition by customer_id order by transaction_dttm) as rn,
  sum(amount_rur) over (partition by customer_id) as sm
  from transactions
  where success_flg = True
)
select  transaction_id, customer_id, amount_rur, transaction_dttm
from tmp
where rn = 1 and sm > 1000000
 ```

  # [3] Задача 

 ```sql
with tmp as (
  select transaction_id, customer_id, amount_rur,
  lag(amount_rur) over (partition by customer_id order by transaction_dttm) as lg,
  lead(amount_rur) over (partition by customer_id order by transaction_dttm) as ld
)
select transaction_id, customer_id, amount_rur
from tmp
where amount_rur > lg and amount_rur < ld
 ```

# [4] Задача 

 ```sql
with tmp as (select client_id, sum(amount) as sm
from transaction t join account a on t.account_id = a.id
where transaction_date > current_date - interval '1 month'
and type = 'покупка'
group by client_id)
select distinct name
from client c join account a2 on c.id = a2.client_id
where close_dt is null
and c.id in (select client_id from tmp where sm < 5000)
and open_dt < current_date - interval '1 year'
 ```

# [5] Задача 

 ```sql
SELECT 
    c1.id,
    c1.points,
    COUNT(DISTINCT c2.points) + 1 as position
FROM sandbox.zvereva_competition c1
LEFT JOIN sandbox.zvereva_competition c2 ON c2.points > c1.points
GROUP BY c1.id, c1.points
ORDER BY c1.points DESC;
 ```
</details>


<details>
  <summary>Лига цифровой экономики</summary>

пн

# [1] Задача 

t1: 3   t2: 4
INNER JOIN
min: 0
max: 12

LEFT JOIN
min: 3
max: 12

RIGHT JOIN
min: 4
max: 12

FULL JOIN
min: 4
max: 12

CROSS JOIN
min: 12
max: 12


 # [2] Задача 

 ```sql
SELECT value, count(value) as cnt
from T
group by value
having count(value) > 1
 ```

# [3] Задача 

 ```sql
tmp as (SELECT empl_fio, empl_dep, amount,
row_number() over (partition by empl_dep order by amount desc) as rn
from salary
where extract(month from value_day) = 4
and extract(year from value_day) = 2023)
select empl_fio, empl_dep, amount from tmp
where rn = 2
 ```

 # [4] Задача 

 ```sql
with tmp as (select empl_fio, empl_dep, amount as may_amount,
dense_rank() over (order by amount) as rank
from salary
where extract(month from value_day) = 5
and extract(year from value_day) = 2023),

apr as (
  select empl_fio, empl_dep, amount as april_amount, value_day
  from salary
  where extract(month from value_day) = 4
and extract(year from value_day) = 2023) 


select t.empl_fio, t.empl_dep, (may_amount - april_amount) as diff, may_amount
from tmp t join apr a on t.empl_fio = a.empl_fio and t.empl_dep = a.empl_dep 
where rank <= 3
 ```
</details>

<details>
  <summary>Wildberries</summary>

вт

 # [1] Задача 

 ```sql
select t1.id, t1.name, t1.salary, t2.salary
from employee t1 join employee t2 on t1.manager_id = t2.id and t1.salary > t2.salary

 ```

 # [2] Задача 

 ```sql
with tmp as (select id, name, salary, departmentID,
dense_rank() over (partition by departmentID order by salary desc) as rk
from employee)
select name
from tmp
where rk <= 3
 ```
# [3] Задача 

 ```python
'''Напишите функцию, которая принимает на вход список hours (содержащий N элементов) и целое число target.
Функция должна возвращать количество сотрудников, отработавших не меньше target часов'''

def func(hours, target):
  cnt = 0
  for i in range(len(hours)):
    if hours[i] >= target:
      cnt += 1
  return cnt
 ```

 # [3] Задача 

 ```python
df['DepositionSum'].mean()
df['WithdrawalSum'].mean()

df.groupby('Day').agg({'DepositionSum': 'mean',
                       'WithdrawalSum': 'mean'}).mean()

df.groupby('UserId').agg({'DepositionSum': 'mean',
                       'WithdrawalSum': 'mean'}).mean()

df['DepositionSum'].sum() - df['WithdrawalSum'].sum()

'''Сегментация: k-means, по сумме депозита, по частоте'''

 ```

</details>

<details>
  <summary>Бетсити</summary>

ср

 # [1] Задача 

 d

 # [2] Задача 

 bc

b. TRUNCATE TABLE my_table - удаляет все строки, быстрее, нельзя откатить
c. DELETE FROM my_table - удаляет все строки, можно использовать с WHERE, можно откатить
a. DROP TABLE my_table - удаляет саму таблицу
d. DELETE my_table - неверный синтаксис (требуется FROM)

 # [3] Задача 

(4500*20+1500*50+2500*30)/100
2400

 # [4] Задача 

Доходы с контрольной группы: 1500
Доходы с целевой группы: 18000
Расходы на рассылку контроль: 500
Расходы на рассылку целевая: 4500

Прибыль со старой конверсией:
10000*0.03*50 = 15000

Прибыль с новой конверсией:
10000*0.04*50 - 5000 = 15000

Итого: эффекта нет


# [5] Задача 

 ```sql
select t1.name, t1.salary, t2.name, t2.salary, t3.name
from employee t1 join employee t2 on t1.chief_id = t2.id 
join department t3 on t1.department_id = t3.id
where t2.salary / t1.salary between 1.5 and 2
 ```


# [6] Задача 

 ```sql
select extract (month from sale_dttm) as month, extract (year from sale_dttm) as year,
percentile_cont(0.5) within group (order by price * (1-discount/100))
from tmp
group by year, month
order by year, month
 ```



</details>


<details>
  <summary>Wildberries</summary>

чт

 # [1] Задача 

 ```sql
with tmp as (select courier_id, pickup_point,
avg(delivery_time) as ag
from orders
where delivery_time <= 120
group by courier_id, pickup_point),

tmp_2 as (select pickup_point, courier_id, 
row_number() over (partition by pickup_point order by ag) as rn
from tmp)

select pickup_point, courier_id from tmp_2
where rn = 1
 ```

# [2] Задача 

 ```sql
with tmp as (select order_date, courier_id, avg(delivery_time) as ag_days
from deliveries
group by order_date, courier_id)

select order_date, courier_id,
avg (ag_days) over (partition by courier_id order by order_date rows between 6 preceding and current row)
from tmp
 ```

# [3] Задача 

 ```python
 import pandas as pd
 df = pd.read_csv('Таблица')

 df.groupby('courier_id').agg({'delivery_time':'mean', 'distance':'mean'})

df['efficiency'] = df['distance']/df['delivery_time']
df.groupby(['start_location', 'end_location']).agg({'efficiency': 'mean'})

df.groupby('courier_id')['efficiency'].mean().sort_values(ascending=False)
 ```

</details>

<details>
  <summary>HeadHunter</summary>

пт

# [1] Задача 

 ```sql
with tmp as (
  select product_id, extract(year from sale_date) as yr, extract(month from sale_date) as mh,
sum(amount) over (partition by product_id, extract(year from sale_date), extract(month from sale_date)) as sm
from sales),
tmp_2 as (
  select product_id, yr, mh, sm,
  lag(sm) over (partition by product_id order by yr, mh) as lg
  from tmp
)
select product_id, yr, mh, coalesce((sm-lg)/nullif(lg,0),0)*100 as final
from tmp_2
order by yr, mh
 ```

# [2] Задача 

 ```python
def func(x):
  cnt = 0
  if not isinstance (x,int):
    return 'Не целое число'
  if x < 0:
    return 'Отрицательное число не может быть составным'
  elif x == 1 or x == 0:
    return 'Ни простое, ни составное'
  else:
    for i in range (2, x+1):
      if x%i == 0:
        cnt += 1
    if cnt == 1:
      return 'Простое'
    else:
      return 'Составное'
 ```

 # [3] Задача 

 ```python
def func(n):
  nums = [0, 1]
  for i in range(2,n+1):
    nums.append(nums[i-1] + nums[i - 2])
  return nums[n]
 ```
 # [4] Задача 

Чему равна вероятность выпадения двух шестерок на двух игральных костях, если сумма выпавших очков четна

С - сумма выпавших очков четна
P(C) = 1/2
так как
18*2 - всего случаев
четных - 18

Р(А) - вероятность выпадения двух шестерок
1/36 

Р(С|A) - вероятность выпасть четному кол-ву очков, если выпали 2 шестерки = 1

Р(А|C) = Р(В|A)*P(A)/P(C) = 1/36 * 2/1 = 1/18

# [5] Задача 

Кидаем 5 раз монетку. Какая вероятность того, что Орел выпадет 3 раза из 5 в любом порядке?

Кол-во благоприятных исходов: С(3,5) = 5!/2!*3! = 10
Кол-во всех исходов: 2*2*2*2*2 = 32
Ответ: 10/32 = 5/16

</details>

<details>
  <summary>CloudPayments</summary>

сб
 # [1] Задача 

 ```sql
select distinct student_id from students 
where student_id not in(
  select student_id from students s join marks m on s.id = m.student_id 
  where mark in (1,2,3)
)
 ```

 # [2] Задача 

 ```sql

with tmp as (select m.id, 
sum(amount) over (partition by m.id) as sm,
row_number() over (partition by m.id order by date_trans desc) as rn
from merchant m inner join merch_transaction t on m.id = t.merch_id
where type = 'Успешно')
select id, sm from tmp
where rn = 1

 ```
 # [3] Задача 

 ```sql
select id, 
sum(amount) over (partition by m.id order by date_trans) as sm
from merchant m inner join merch_transaction t on m.id = t.merch_id
where type = 'Успешно'
 ```
 # [4] Задача 

 ```python
df_final = df_amounts.groupby('scopeid')['amount'].sum().sort_values(ascending = False).head(3)
df_final = df_final.reset_index()
df_final = df_final.merge(df_names, on = 'scopeid', how = 'left')
df_final[['scope_name', 'amount']]
 ```

</details>


</details>


<details>
  <summary>Ноябрь 2025</summary>

<details>
  <summary>Точка 2</summary>
  вс

 # [1] Задача 

- Объяснить, в чём принципиальная разница в результате между этими двумя запросами.

В ON - фильтрация выполняется во время соединения, то есть из второй таблицы не возьмутся строки с id>=5
В where - фильтрация происходит уже после соединения, то есть из всей готовой таблицы удалятся те строки, где b.id>=5 

- На небольшом примере данных (в том числе с значениями 2, 5, 10) показать, какие строки попадут в результат каждого запроса.

2 кот    
5 собака
10 мышь

2 кот
7 крыса
10 мышь

вариант 1 с where:
10 мышь мышь

вариант 2 с on:

2 кот null
5 собака null
10 мышь мышь

# [2] Задача 

 ```sql

-- Написать SQL-скрипт, который позволит однозначно ответить на вопрос: совпадают ли результаты этих двух выборок или нет

with diff as (select a.id, b.id
from a full outer join b on a.id = b.id or (a.id is Null and b.id is Null)
where a.id is distinct from b.id)
select 
case
when exists (select True from diff) then 'Отличия есть'
else 'Отличий нет'
end as result
 ```
# [3] Задача - Продуктовый кейс: отдел обзвона клиентов

В компании есть отдел, который обзванивает клиентов и продаёт им продукт. Руководству нужно понять, оставлять ли этот отдел в следующем году или закрывать.

Известно:

Оператор делает около 100 звонков в день.
Конверсия в подключение по результатам обзвона — 5%.
С одной продажи компания получает 3000 ₽ (считать это чистой маржой).
Зарплата сотрудника — порядка 70 000 ₽ в месяц + налоги (итого около 100 000 ₽ совокупных затрат).
Без обзвона есть «естественная» конверсия клиентов в подключение — 3%.
Нужно:

Предложить, какие метрики и расчёты нужно сделать, чтобы решить, выгоден ли отдел обзвона.
Показать, как учесть естественную конверсию (3%) и выделить именно дополнительный эффект от работы оператора.
Сравнить дополнительную выручку/маржу с затратами на отдел и сделать вывод, стоит ли его оставлять.


1) Если после обзвона конверсия 5, а естественная 3, то тогда эти +2% - полученная выгода

100 * 0.02 * 3000 = 6000 - это прибыль с одного сотрудника за день

за месяц с одного сотрудника прибыль: 6000 * 22 рабочих дня - 100000 = 32 000

2) Можно предложить метрику ROMI

(доп прибыль)/ затраты = 132000/100000 = 132% (> 100%, значит вложения окупаются)
Решение: оставлять отдел обзвона
 </details>

<details>
  <summary>Билайн</summary>
  пн


# [1] Задача  Сумма положительных и отрицательных значений

 ```sql
--Есть таблица values_table с единственным числовым полем v. В этом поле могут быть как положительные, так и отрицательные значения. Требуется написать SQL-запрос, который посчитает:

-- сумму всех положительных значений поля v;
-- сумму всех отрицательных значений поля v.

SELECT 
    SUM(CASE WHEN v > 0 THEN v ELSE 0 END) AS sum_posit,
    SUM(CASE WHEN v < 0 THEN v ELSE 0 END) AS sum_negat
FROM values_table;
 ```


# [2] Задача Группировка чисел по диапазонам

 ```sql

-- Используя ту же таблицу values_table(v), нужно сгруппировать все значения по диапазонам одинаковой ширины, например по 1000 единиц: от -2000 до -1000, от -1000 до 0, от 0 до 1000, от 1000 до 2000 и т.д. Требуется написать SQL-запрос, который:

-- относит каждое значение v к соответствующему диапазону;
-- считает количество значений в каждом диапазоне;
-- выводит только те диапазоны, в которых есть хотя бы одно значение.

with tmp as (select v,
case 
when v >= -2000 and v < -1000 then 'от -2000 до -1000'
when v >= -1000 and v < 0 then 'от -1000 до 0'
when v >= 0 and v < 1000 then 'от 0 до 1000'
when v >= 1000 and v <= 2000 then 'от 1000 до 2000'
end as group_range
from values_table)
select group_range,
count(v) as cnt_v
from tmp
where group_range is not null
group by group_range
 ```
</details>
</details>



<details>
  <summary>Декабрь 2025</summary>

<details>
  <summary>Сбер</summary>
  вт

# [1] Задача

 ```sql
--Сколько клиентов видели рекламу не менее 2х раз

select id, count(id) as cnt
from events 
where event = 'SHOWN'
group by id
having count(id) >= 2
 ```

 # [2] Задача

 ```sql
--Сколько было показов и кликов
select
count(case when event = 'SHOWN' then 1 end) as shown,
count(case when event = 'STARTED' then 1 end) as started
from events

-- Конверсия клики/показы
with tmp as (select
count(case when event = 'SHOWN' then 1 end) as shown,
count(case when event = 'STARTED' then 1 end) as started
from events)
select round(started::float/shown,2)*100 as cr
from tmp

-- Сколько было сделано продаж в течение 4х дней после клика?

with tmp as (select id, s.ts as ts_sale, e.ts as ts_click
from sales s left join events e on s.id = e.id and e.event = 'STARTED' and s.ts > e.ts)
select count (distinct id)
from tmp
where datediff('dd', ts_click, ts_sale) <= 4 and ts_click is not null
 ```

 # [3] Кейс АБ

Проведен АБ тест - показаны 2 разных кредита разным группам людей.
Полученные результаты показывают отсутствие разницы между сtr.
Вы сомневаетесь в правильности выводов, поскольку это противоречит ранее проведенным исследованиям, которые проводили не вы.
С чем вы связываете отсутствие различия?

Что нужно проверить?
- корректность проведения аб теста (нет ли peeking prblem, srm, сколько держали аб и набралась ли достаточная выборка, корректно ли выбран стат критерий)
- было ли соблюдено правило случайного распределения пользователей, действительно ли пользователь оказался только в одной группе
- не было ли такого, что тестировали на разных каналах привлечения
- не проводился ли тест в праздники? или других отличные от будней дней?
- не было ли множественного тестирования
- возможно была выбрана некорректная метрика
- баги

 # [4] Кейс

 Ситуация: пришел на работу -> витрина пустая в БД. Что делать?

1) Посмотрю рабочие чаты и почту - вдруг DE уже предупредили о проблеме?
2) Пойду узнаю у ответственных за витрину - если это не моя ответственность
3) Если моя, то пойду проверять, что сломалось:
- проверю логи, алерты, чтобы понять, когда витрина упала
- проверю, когда были сделаны последние изменения
- проверю, все ли окей с источником данных
- если есть бэкап, то временно поднимаю витрину из бэкапа
- запускаю бэктил (перерасчет данных)
- иду к de

Какие вопросы важно задать?

Когда перестала работать? (по логам/мониторингу)
Что изменилось перед этим? (деплой, изменение данных, нагрузки)
Кто использует витрину? (чтобы оценить срочность)
Есть ли бэкап/ snapshot? (можно ли быстро восстановить)

<details>


</details>